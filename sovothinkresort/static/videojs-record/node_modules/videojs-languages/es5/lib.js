'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _flatten = require('flatten');

var _flatten2 = _interopRequireDefault(_flatten);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _globby = require('globby');

var _globby2 = _interopRequireDefault(_globby);

var _mkdirp = require('mkdirp');

var _mkdirp2 = _interopRequireDefault(_mkdirp);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

/**
 * Determines if a value is a non-empty string.
 *
 * @private
 * @param  {Mixed} v
 * @return {Boolean}
 */
var nonEmptyStr = function nonEmptyStr(v) {
  return typeof v === 'string' && /\S/.test(v);
};

/**
 * Normalize a patterns string/array into an array of non-empty strings,
 * defaulting to ["lang/*.json"].
 *
 * @private
 * @param  {Array|String} patterns
 * @return {Array}
 */
var normalizePatterns = function normalizePatterns(patterns) {

  // Normalize valid, non-empty string arguments into an array.
  if (nonEmptyStr(patterns)) {
    return [patterns];
  }

  // Default to the "lang" dir in the cwd in the case of invalid or an
  // effectively empty patterns array.
  if (!Array.isArray(patterns) || !patterns.some(nonEmptyStr)) {
    return ['lang/*.json'];
  }

  return patterns.filter(nonEmptyStr);
};

/**
 * Normalize a directory by verifying that it exists - or returning null.
 *
 * @private
 * @param  {String} [dir]
 * @return {String|undefined}
 */
var normalizeDir = function normalizeDir(dir) {
  if (nonEmptyStr(dir)) {
    try {

      // mkdirp will do nothing if the directory exists or it will create
      // it if it does not. The only reason it should fail is if the
      // Node process can't write to the path for whatever reason. In that
      // case, we catch and treat the dir as invalid.
      _mkdirp2['default'].sync(dir);
      return dir;
    } catch (x) {
      return;
    }
  }
  return;
};

/**
 * Takes an array of source .json files and an optional destination
 * directory and returns an array of destination .js files.
 *
 * @private
 * @param  {String} src
 * @param  {String|null} dir
 * @return {String}
 *         The path to the destination .js file.
 */
var destination = function destination(src, dir) {
  var d = dir || _path2['default'].dirname(src);
  var bn = _path2['default'].basename(src);

  // We can assume the basename ends in ".json", so we only need to pop
  // off the "on" to get the proper extension.
  return _path2['default'].join(d, bn.substr(0, bn.length - 2));
};

/**
 * Takes an array of patterns and returns an array of matching .json
 * filenames.
 *
 * @private
 * @param  {Array} patterns
 * @return {Array}
 */
var findSources = function findSources(patterns) {
  return (0, _flatten2['default'])(_globby2['default'].sync(patterns).filter(function (f) {
    return _path2['default'].extname(f) === '.json';
  }));
};

/**
 * Process an array of source .json files into an optional dir, output
 * as .js files.
 *
 * @private
 * @param  {Array} srces
 * @param  {String|null} dir
 * @return {Array}
 */
var processSources = function processSources(srces, dir) {
  return srces.map(function (src) {
    var dest = destination(src, dir);

    // Here, we parse and then re-stringify the file contents to ensure
    // they are valid JSON.
    var json = JSON.parse(_fs2['default'].readFileSync(src, 'utf8'));
    var lang = _path2['default'].basename(src, '.json');
    var data = JSON.stringify(json, null, '  ');

    _fs2['default'].writeFileSync(dest, 'videojs.addLanguage(\'' + lang + '\', ' + data + ');');

    return dest;
  });
};

exports.nonEmptyStr = nonEmptyStr;
exports.normalizePatterns = normalizePatterns;
exports.normalizeDir = normalizeDir;
exports.destination = destination;
exports.findSources = findSources;
exports.processSources = processSources;